---
description: Global workspace rules — Sierac-tm project core process, principles, and pointers to domain rules.
globs:
  - "*"
alwaysApply: true
---
# Sierac-tm 工作指导总纲

> **版本**: v2.0.0 (2026-02-25)
> **项目**: Sierac-tm — AI 团队贡献可视化与激励平台
> **许可证**: MIT

---

## 〇、项目定位（战略重定义）

Sierac-tm **不是**一个用量监控工具。它是一个**以贡献可视化驱动团队积极性的平台**。

> **核心理念：让贡献被看见，让积极性自然生长。**

### 业务目标

| 层次 | 目标 | 说明 |
|------|------|------|
| **战略** | 用贡献驱动积极性 | 不是监控谁用了多少，而是展示谁贡献了什么 |
| **业务** | 成员贡献可视化 | 让每个人的产出有据可查、有图可看、有排名可比 |
| **产品** | 激励闭环 | 贡献可见 → 排行激励 → 主动参与 → 贡献更多 |

### 与「用量监控」的本质区别

| 维度 | 用量监控（旧定位） | 贡献可视化（新定位） |
|------|---------------------|----------------------|
| **看什么** | 请求数、Token、支出 | 代码产出、项目参与、效率 |
| **给谁看** | 管理员 | 管理员 + 成员自己 |
| **驱动什么** | 成本控制 | 积极性、荣誉感 |
| **成员感受** | 被监控 | 被认可 |
| **数据来源** | Cursor API + Hook | Cursor API + Git + Hook（多源融合） |

### 产品愿景

**Phase 0 — 项目立项与治理**：管理员在平台注册公司项目（仓库地址、工作目录规则、成员），形成白名单；Hook 据此放行或拦截，确保公司 Token 只用于公司项目。
**Phase 1 — 贡献可见**：成员能看到自己和团队在已立项项目上的贡献（代码产出、项目参与、AI 使用效率），管理员能看到全局。
**Phase 2 — 激励闭环**：贡献度评分、排行榜、周期快照，与团队激励机制挂钩。
**Phase 3 — 团队洞察**：项目健康度、团队协作热力图、趋势分析，辅助管理决策。

---

## 一、文档结构

| 文档 | 内容 | 状态 |
|------|------|------|
| **主文档** (本文档) | 核心索引、项目定位、工作流程 | ✅ |
| **核心原则** | `.cursor/rules/sierac_principles.mdc` | ✅ |
| **开发规范** | `.cursor/rules/sierac_development.mdc` | ✅ |
| **架构规范** | `.cursor/rules/sierac_architecture.mdc` | ✅ |
| **测试规范** | `.cursor/rules/sierac_testing.mdc` | ✅ |
| **Spec 标准** | `.cursor/rules/sierac_spec_standards.mdc` | ✅ |
| **数据库规范** | `.cursor/rules/sierac_database.mdc` | ✅ |
| **总体架构** | `docs/ARCHITECTURE.md`（唯一架构真源） | 🔄 需按新定位更新 |

---

## 二、AI 必读文档

### 按阅读场景

| 阅读场景 | 文档 | 内容 |
|----------|------|------|
| 每次 | 本文档 | 项目定位（贡献可视化，不是用量监控）与核心原则 |
| 每次 | `docs/ARCHITECTURE.md` | 架构设计（唯一真源） |
| 开发 | `.cursor/rules/sierac_principles.mdc` | 核心原则（代码质量、禁止行为） |
| 开发 | `.cursor/rules/sierac_development.mdc` | 开发规范（流程、Git、依赖管理） |
| 架构 | `.cursor/rules/sierac_architecture.mdc` | 架构规范（包结构、集成边界） |
| 数据库 | `.cursor/rules/sierac_database.mdc` | 数据库编码规范 |
| 测试 | `.cursor/rules/sierac_testing.mdc` | 测试规范 |
| 写/改 spec | `.cursor/rules/sierac_spec_standards.mdc` | Spec 文档标准 |
| 写/改 spec | `.kiro/SPEC_DOCUMENTATION_STANDARD.md` | Spec 三层文档结构详细规范 |

### AI 工作流程

```
1. 接收任务
 ↓
2. 阅读本文档（项目定位：贡献可视化，不是监控）
 ↓
3. 根据任务类型阅读相关子文档
 ↓
4. 阅读 docs/ARCHITECTURE.md（理解架构决策）
 ↓
5. 检查影响范围（grep 搜索）
 ↓
6. 新功能/重大重构：确认已有 spec（三层齐全）再编码；无 spec 则先补齐
 ↓
7. 阅读相关代码
 ↓
8. 开始编码
```

---

## 三、关键规则速查

### 业务规则

| 规则 | 说明 | 详细文档 |
|------|------|---------|
| **项目先立项** | 公司项目必须在管理平台注册后才能使用公司 Cursor Token；立项 = 白名单入口 | 本文档 §四 |
| **贡献优先于用量** | 展示的核心是「产出了什么」而非「消耗了多少」；用量数据仅作为效率参考 | 本文档 §〇 |
| **成员视角优先** | 先做「我的贡献」让成员看到自己的价值，再做管理员排行 | 本文档 §〇 Phase 规划 |
| **多源融合** | 贡献数据不依赖单一来源；Cursor API（用量）+ Git（代码产出）+ Hook（项目参与）组合 | `sierac_architecture.mdc` |
| **激励而非监控** | UI 措辞、数据展示方式必须传达「认可」而非「监视」；禁止展示负面排名 | 本文档 §〇 |
| **治理是贡献的副产品** | 同一份数据：成员看到「我的贡献」，管理员看到「贡献 + 合规」；不做额外监控层 | 本文档 §四 |
| **防刷设计** | 贡献度多维度、可配置权重、设合理上限；不依赖单一指标 | `cursor-admin-incentives/requirements.md` §4 |

### 技术规则

| 规则 | 说明 | 详细文档 |
|------|------|---------|
| **禁止 TODO 预留** | 代码中不留 TODO/FIXME，未完成功能记录在 tasks.md | `sierac_development.mdc` |
| **依赖管理** | Python: Poetry; Node: npm; Java: Maven | `sierac_development.mdc` |
| **Python >= 3.10** | 类型注解用现代语法 | `sierac_development.mdc` |
| **禁止假数据** | 数据获取失败返回空结果，不返回硬编码备用数据 | `sierac_principles.mdc` |
| **先规划后执行** | 重构/修改前必须制定完整方案 | `sierac_development.mdc` |
| **Spec 文档规范** | 新功能和重大重构必须使用三层文档结构 | `sierac_spec_standards.mdc` |
| **Spec 循环** | 触发词「继续」驱动多轮，SPEC_TASKS_SCAN 为单一真源 | 本文档第四节 |
| **代码英文/文档中文** | 代码注释 English，文档中文 | `sierac_principles.mdc` |
| **Cursor API 单点出口** | 所有 Cursor API 调用必须经 `cursor_api.py` | `sierac_architecture.mdc` |
| **Hook 协议统一** | Hook 与 collector 之间仅通过 HTTP JSON 契约通信 | `sierac_architecture.mdc` |

---

## 四、项目立项与治理层

### 4.1 核心概念：立项 = 白名单入口 + 仓库自动创建

```
管理员在平台「立项」
    ↓
填写项目信息（名称、描述、成员、仓库 slug）
    ↓
平台自动在 GitLab 创建仓库（含 .cursor/ Hook 目录）
    ↓
自动添加成员到仓库（Developer 权限）
    ↓
形成「已立项项目白名单」
    ↓
成员 clone 仓库 → Hook 自动生效
    ↓
Hook 检查 workspace_roots 是否匹配已立项项目
    ├─ 匹配 → 放行，上报归属到该项目
    └─ 不匹配 → 拦截，提示「请在公司项目中使用」
```

**项目（Project）是平台的一等实体**：所有贡献数据、参与数据、治理策略都围绕「项目」组织，而不是裸的工作目录路径。

**仓库即准入凭证**：立项自动创建的仓库内含 Hook，成员 clone 即获得准入；未立项 = 无仓库 = 无 Hook = 无法通过企业 Cursor 编程。

### 4.2 项目数据模型

| 字段 | 说明 |
|------|------|
| `id` | 项目 ID |
| `name` | 项目名称（如「Sierac-tm」「OwlClaw」） |
| `git_repos` | 关联的 Git 仓库地址（可多个） |
| `workspace_rules` | 工作目录匹配规则（路径前缀/正则，可多条） |
| `members` | 参与成员（可选，不填则全员可用） |
| `status` | 状态（active / archived） |
| `gitlab_project_id` | GitLab 项目 ID（自动创建时回填） |
| `repo_url` / `repo_ssh_url` | 仓库 clone 地址 |
| `hook_initialized` | Hook 是否已注入仓库 |
| `created_by` | 立项人 |
| `created_at` / `updated_at` | 时间戳 |

### 4.3 治理流程

**事前防护（Hook 主动拦截）**：

- Hook 的 `beforeSubmitPrompt` 从 collector 获取白名单（可缓存），检查当前 `workspace_roots` 是否匹配任一已立项项目的 `workspace_rules`
- 匹配 → `{"continue": true}`，正常上报并标记所属项目
- 不匹配 → `{"continue": false, "message": "当前工作目录未在公司项目白名单中，请联系管理员立项"}`

**事后可见（贡献数据自然暴露）**：

- 贡献数据按项目聚合展示，而非裸路径
- 管理员可看到「哪些成员在哪些项目有产出」
- 异常信号：某成员本周期无任何已立项项目的贡献 → 提醒（非告警）

### 4.4 同一份数据，两种叙事

| 功能 | 成员看到的 | 管理员看到的 |
|------|-----------|-------------|
| 我的贡献 | 我在哪些项目产出了代码 | 同左 |
| 项目参与 | 我参与了哪些公司项目 | 谁参与了哪些项目、参与深度 |
| 工作目录策略 | （无感知，被拦截时收到提示） | 项目立项管理、白名单配置 |
| 异常提醒 | — | 某成员本周期无公司项目产出 |

### 4.5 与现有模块的关系

| 模块 | 变化 |
|------|------|
| **工作目录页** | 改造为「项目参与」页，按已立项项目聚合，不再展示裸路径 |
| **Hook** | 增加白名单检查逻辑（beforeSubmitPrompt），上报时标记所属项目 |
| **Collector** | 新增项目 CRUD API、白名单查询 API、GitLab 仓库创建集成 |
| **GitLab** | 通过 `gitlab_client.py` 单点调用：仓库创建、Hook 注入、成员管理 |
| **DB** | 新增 `projects` 表（含 GitLab 关联字段） |

---

## 五、贡献数据模型（战略级设计）

### 5.1 「贡献」的定义

贡献 ≠ 用量。贡献是成员通过 AI 辅助开发**实际产出的可度量成果**。

| 维度 | 数据来源 | 含义 | 权重建议 |
|------|----------|------|----------|
| **代码产出** | Git（commit diff） | 实际写了多少代码、改了多少文件 | 高 |
| **项目参与** | Git + Hook | 参与了哪些项目/仓库、参与深度 | 高 |
| **AI 使用效率** | Cursor API | 用 AI 产出代码的效率（请求数 vs 代码产出比） | 中 |
| **协作贡献** | Git（PR/Review） | 代码审查、合并请求 | 中 |
| **持续性** | 综合 | 连续活跃天数、稳定产出 | 低 |

### 5.2 数据采集策略

```
┌─────────────────────────────────────────────────────┐
│                   贡献数据融合                         │
│                                                       │
│  Cursor Admin API ──► 用量（请求数、Token、支出）       │
│       (定时拉取)       → 效率维度的分母                 │
│                                                       │
│  Git 仓库分析 ──────► 代码产出（commit、diff、PR）      │
│       (定时扫描)       → 贡献的核心度量                 │
│                                                       │
│  Cursor Hook ────────► 项目参与（哪个目录、多久）       │
│       (实时上报)       → 参与度的补充信号               │
│                                                       │
│           ↓ 融合计算 ↓                                 │
│                                                       │
│  contribution_scores ──► 排行、趋势、个人画像           │
└─────────────────────────────────────────────────────┘
```

**关键决策**：
- **Git 是贡献的第一数据源**：代码产出是最客观、最难作假的贡献度量。
- **Cursor API 是效率参考**：用量本身不是贡献，但「用 N 次请求产出 M 行代码」是效率。
- **Hook 是参与信号**：知道谁在哪个项目活跃，补充 Git 无法覆盖的场景（如调试、阅读、探索）。
- **三源缺一可降级**：未装 Hook 的成员仍有 Git + API 数据；未配 Git 的仍有 API + Hook。

### 5.3 与现有实现的关系

| 现有模块 | 保留/改造 | 说明 |
|----------|-----------|------|
| Cursor API 同步（members, daily_usage, spend） | **保留** | 作为效率维度的数据源 |
| Hook 上报（agent_sessions） | **保留并增强** | 增加更多事件（beforeSubmitPrompt 等），但核心价值是「项目参与信号」 |
| 告警（alert_rules, alert_events） | **保留** | 支出告警仍有价值 |
| 工作目录页 | **改造** | 从「工作目录列表」改为「项目参与度」视图 |
| 用量页 | **改造** | 从「用量统计」改为「AI 使用效率」视图 |
| **新增：项目立项** | **新建** | 项目 CRUD、白名单管理、Hook 拦截策略（Phase 0） |
| **新增：Git 采集** | **新建** | 定时扫描已立项项目的 Git 仓库，提取 commit/diff/PR 数据 |
| **新增：贡献度计算** | **新建** | 融合三源数据，按可配置规则计算得分 |
| **新增：我的贡献** | **新建** | 成员端个人贡献画像 |
| **新增：排行榜** | **新建** | 团队贡献排行与趋势 |

---

## 六、Spec 循环（触发词：spec循环 / 继续 / 挨个完成 / 全部完成 / 持续推进 / 自主推进）

**Goal**：将 SPEC_TASKS_SCAN 功能清单与各 spec 的 tasks.md 中 `[ ]` 通过实现+验收变为 `[x]`，直至无未勾项或用户叫停。

**持续/自主推进**：用户可通过**反复发送「继续」**实现多轮推进，无需每次重述「spec 循环」。每轮结束时若**未达 Exit**，AI **必须**在回复末尾给出明确提示，例如：「**回复「继续」以执行下一轮 spec 循环。**」触发词包括：`spec循环`、`继续`、`挨个完成`、`全部完成`、`持续推进`、`自主推进`。

**Authority**：`.kiro/specs/SPEC_TASKS_SCAN.md` 功能清单；各 spec 的 `tasks.md`。收口 = task 内全部 `[x]` 且实现+验收通过 → 功能清单对应行打勾。

### Rules

- **验收标准**：仅当实现+验收通过可打勾；不得以 deferred/按需代替；未实现保留 `[ ]` 记 design/backlog。写入 spec 的 task = 必须完成（不做的放 backlog/单独 spec）；功能清单须 ⊇ 各 spec tasks，缺则补。
- **批次控制**：单次循环最多完成 3 个 task（或 1 个复杂 spec）；建议每轮 1～3 项，不必凑满。完成后必须更新文档、检查点，然后评估是否继续。避免单次循环过长导致上下文溢出。
- **Context 管理（/compact）**：每完成一个完整 spec（所有 task `[x]`）后，或累计执行超过 5 轮后，必须执行 `/compact` 压缩当前对话上下文，再继续下一 spec。
- **失败处理**：验收失败时必须分析原因 → 若设计问题回退到 design.md 修正；若实现问题回滚代码重新实现；若依赖问题标记 blocked 并记录依赖。同一 task 连续失败 3 次自动标记 blocked。
- **持续推进**：SPEC_TASKS_SCAN 或 tasks.md 有 `[ ]` → 必须执行下一可执行项或产出可执行项（拆解/新增 spec）；不得以无可执行、内部依赖未就绪为由停；仅**外部不可控依赖**可写明后收口。
- **连续执行**：文档/契约/Task 0 完成后须检查该 spec 下一未勾 task 是否可立即实现，若可则接着做并打勾，直至无可实现或写明依赖。
- **禁止中途汇报**：未达 Exit 前不得输出「本轮收口」「无可执行」并等待用户；若已写「下一执行批次」须取至少一项实现+验收+打勾。
- **每轮提交**：每一轮 spec 循环结束后，必须对当前变更执行一次 **git commit**。
- **资源释放（防死机）**：每轮 spec 循环执行测试后，必须确保子进程已退出。优先使用 `pytest --timeout=30`；禁止后台启动测试不等待；每批次测试结束后清理残留进程。

### Loop

1. **Check** — 功能清单 ⊇ 各 spec tasks；缺则补。取未打勾项与 tasks.md 中 `[ ]`。**Health Check**：同一 task 连续失败 ≥3 次 → 标记 blocked；单个 spec 连续 >10 轮无进展 → 提示用户介入。
2. **Plan** — 选择下一批次（建议 1～3 个 task），评估依赖关系与优先级。
3. **Do** — 对当前批次的每个 task：Act → Observe → Reflect → Verify。通过 → `[x]`；失败 → 分析/回滚/blocked。若本 spec 仍有可实现的下一 task，继续执行。
4. **Doc** — 更新 SPEC_TASKS_SCAN 检查点。
5. **Commit** — git commit，提交信息含本轮完成项。
6. **Evaluate** — 仍有 `[ ]` → 回 1。

### Exit

1. 用户叫停
2. 功能清单与所有 tasks.md 均已全部打勾
3. 当前批次完成，下一批次需用户决策或外部输入
4. 所有剩余项均为外部不可控依赖
5. 健康检查触发（同一 task 连续失败 3 次、单 spec >10 轮无进展）

---

## 七、执行承诺

- **贡献优先于用量**：所有功能设计以「展示贡献」为出发点，不做纯监控
- 代码英文，文档中文
- 先规划后执行，一次到位
- 依赖管理：Python 用 Poetry，Node 用 npm
- 测试覆盖关键路径
- Spec 文档规范，新功能必须使用三层文档结构
- 集成组件保持隔离，方便替换
- Spec 循环驱动开发，SPEC_TASKS_SCAN 为单一真源
- **禁止假数据**：数据获取失败返回空结果，不返回硬编码备用数据

---

**维护者**: yeemio
**下次审核**: 2026-03-15
