"""
GitLab API v4 client — single point of contact for all GitLab operations.

Responsibilities:
- Create repositories under a configured group
- Push initial commits (Hook files) via the Repository Files API
- Manage project members
- Inject Hook files into existing repositories
"""

import base64
import json
import logging
import urllib.error
import urllib.parse
import urllib.request
from dataclasses import dataclass
from pathlib import Path

from config import settings

log = logging.getLogger(__name__)

HOOK_TEMPLATES_DIR = Path(__file__).parent / "hook_templates"


@dataclass
class GitLabProject:
    gitlab_project_id: int
    repo_url: str
    repo_ssh_url: str
    web_url: str


class GitLabError(Exception):
    def __init__(self, message: str, status_code: int | None = None):
        super().__init__(message)
        self.status_code = status_code


class GitLabClient:
    """Thin wrapper around GitLab REST API v4."""

    def __init__(
        self,
        url: str | None = None,
        token: str | None = None,
        group_id: int | None = None,
        default_branch: str | None = None,
        visibility: str | None = None,
    ):
        self.base_url = (url or settings.gitlab_url).rstrip("/")
        self.token = token or settings.gitlab_token
        self.group_id = group_id or settings.gitlab_group_id
        self.default_branch = default_branch or settings.gitlab_default_branch
        self.visibility = visibility or settings.gitlab_visibility

    def _request(
        self,
        method: str,
        path: str,
        body: dict | None = None,
    ) -> dict | list | None:
        url = f"{self.base_url}/api/v4{path}"
        data = json.dumps(body).encode("utf-8") if body else None
        req = urllib.request.Request(
            url,
            data=data,
            method=method,
            headers={
                "PRIVATE-TOKEN": self.token,
                "Content-Type": "application/json",
            },
        )
        try:
            with urllib.request.urlopen(req, timeout=30) as resp:
                raw = resp.read()
                if not raw:
                    return None
                return json.loads(raw)
        except urllib.error.HTTPError as exc:
            detail = ""
            try:
                detail = exc.read().decode("utf-8", errors="replace")
            except Exception:
                pass
            log.error("GitLab API %s %s → %s: %s", method, path, exc.code, detail)
            raise GitLabError(
                f"GitLab API error {exc.code}: {detail[:500]}",
                status_code=exc.code,
            ) from exc
        except urllib.error.URLError as exc:
            log.error("GitLab API unreachable: %s", exc.reason)
            raise GitLabError(f"GitLab unreachable: {exc.reason}") from exc

    def is_configured(self) -> bool:
        return bool(self.base_url and self.token and self.group_id)

    def create_project(
        self,
        name: str,
        path_slug: str,
        description: str = "",
    ) -> GitLabProject:
        """Create a new project under the configured group."""
        result = self._request("POST", "/projects", {
            "name": name,
            "path": path_slug,
            "namespace_id": self.group_id,
            "description": description,
            "visibility": self.visibility,
            "initialize_with_readme": False,
            "default_branch": self.default_branch,
        })
        return GitLabProject(
            gitlab_project_id=result["id"],
            repo_url=result.get("http_url_to_repo", ""),
            repo_ssh_url=result.get("ssh_url_to_repo", ""),
            web_url=result.get("web_url", ""),
        )

    def push_initial_commit(
        self,
        gitlab_project_id: int,
        collector_url: str,
        project_id: int,
    ) -> None:
        """Push initial commit with .cursor/ Hook files and .gitignore."""
        files = self._build_hook_files(collector_url, project_id)

        actions = []
        for file_path, content in files.items():
            actions.append({
                "action": "create",
                "file_path": file_path,
                "content": content,
            })

        self._request(
            "POST",
            f"/projects/{gitlab_project_id}/repository/commits",
            {
                "branch": self.default_branch,
                "commit_message": "chore: initialize project with Cursor Hook\n\nAuto-generated by Sierac-tm platform.",
                "actions": actions,
            },
        )
        log.info("Pushed initial commit to GitLab project %d", gitlab_project_id)

    def inject_hook_files(
        self,
        gitlab_project_id: int,
        collector_url: str,
        project_id: int,
        branch: str | None = None,
    ) -> None:
        """Inject or update Hook files in an existing repository via a new commit."""
        target_branch = branch or self.default_branch
        files = self._build_hook_files(collector_url, project_id)

        existing_files = self._list_tree(gitlab_project_id, target_branch)

        actions = []
        for file_path, content in files.items():
            action = "update" if file_path in existing_files else "create"
            actions.append({
                "action": action,
                "file_path": file_path,
                "content": content,
            })

        if not actions:
            return

        self._request(
            "POST",
            f"/projects/{gitlab_project_id}/repository/commits",
            {
                "branch": target_branch,
                "commit_message": "chore: update Cursor Hook files\n\nRe-injected by Sierac-tm platform.",
                "actions": actions,
            },
        )
        log.info("Injected Hook files into GitLab project %d", gitlab_project_id)

    def add_members(
        self,
        gitlab_project_id: int,
        emails: list[str],
        access_level: int = 30,  # 30 = Developer
    ) -> list[str]:
        """Add members to a GitLab project. Returns list of emails that failed."""
        failed: list[str] = []
        for email in emails:
            try:
                user_id = self._find_user_id(email)
                if user_id is None:
                    log.warning("GitLab user not found for email: %s", email)
                    failed.append(email)
                    continue
                self._request(
                    "POST",
                    f"/projects/{gitlab_project_id}/members",
                    {"user_id": user_id, "access_level": access_level},
                )
            except GitLabError as exc:
                if exc.status_code == 409:
                    log.info("User %s already a member, skipping", email)
                else:
                    log.warning("Failed to add member %s: %s", email, exc)
                    failed.append(email)
        return failed

    def _find_user_id(self, email: str) -> int | None:
        encoded = urllib.parse.quote(email, safe="")
        result = self._request("GET", f"/users?search={encoded}")
        if isinstance(result, list):
            for user in result:
                if user.get("email", "").lower() == email.lower():
                    return user["id"]
            if result:
                return result[0]["id"]
        return None

    def _list_tree(
        self, gitlab_project_id: int, branch: str
    ) -> set[str]:
        """List file paths in the repository root (recursive)."""
        try:
            encoded_branch = urllib.parse.quote(branch, safe="")
            result = self._request(
                "GET",
                f"/projects/{gitlab_project_id}/repository/tree?ref={encoded_branch}&recursive=true&per_page=100",
            )
            if isinstance(result, list):
                return {item["path"] for item in result if item.get("type") == "blob"}
        except GitLabError:
            pass
        return set()

    def _build_hook_files(
        self, collector_url: str, project_id: int
    ) -> dict[str, str]:
        """Read Hook templates and substitute variables."""
        files: dict[str, str] = {}

        hooks_json_path = HOOK_TEMPLATES_DIR / "hooks.json"
        if hooks_json_path.exists():
            files[".cursor/hooks.json"] = hooks_json_path.read_text(encoding="utf-8")

        hook_py_path = HOOK_TEMPLATES_DIR / "cursor_hook.py"
        if hook_py_path.exists():
            files[".cursor/hook/cursor_hook.py"] = hook_py_path.read_text(encoding="utf-8")

        config_tmpl_path = HOOK_TEMPLATES_DIR / "hook_config.json.tmpl"
        if config_tmpl_path.exists():
            tmpl = config_tmpl_path.read_text(encoding="utf-8")
            rendered = tmpl.replace("{{collector_url}}", collector_url)
            rendered = rendered.replace("{{project_id}}", str(project_id))
            files[".cursor/hook/hook_config.json"] = rendered

        gitignore_tmpl_path = HOOK_TEMPLATES_DIR / "gitignore.tmpl"
        if gitignore_tmpl_path.exists():
            files[".gitignore"] = gitignore_tmpl_path.read_text(encoding="utf-8")

        return files


gitlab_client = GitLabClient()
